# css/css-sizing/stretch/stretch-alias-min-block-size-001.tentative.html

```json
{
  "format_version": 3,
  "file": "css/css-sizing/stretch/stretch-alias-min-block-size-001.tentative.html"
}
```

## style[0]

```css

  .cb {
    block-size: 50px;
    inline-size: 40px;

    /* This margin & border are purely cosmetic and don't impact the sizing
     * calculations in this test: */
    margin: 5px;
    border: 2px solid black;

    /* This padding only comes into play for the subtests with absolutely
     * positioned children (where our padding-box forms the containing block
     * for the abspos child). */
    padding-block: 5px;
    padding-inline: 3px;

    /* We make each containing block an inline-level box, so we can display
     * subtests in multiple rows, for easier visualization: */
    display: inline-block;
    vertical-align: top;
  }

  .test {
    /* We have 2+3 = 5px of margin in the block axis. This means the stretched
     * children should all have a border-box size that's 5px less than the
     * containing block's content-box size, i.e. 50 - 5 = 45px. */
    margin-block-start: 2px;
    margin-block-end: 3px;

    /* We also have some border/padding that UAs will need to account for
     * when computing the stretched children's content-box sizes; but these
     * don't reduce our `data-expected-height` expectations, since those
     * correspond to the border-box size. */
    border: 3px solid blue;
    padding: 2px;

    /* We expect "min-block-size:stretch" to cause the used value of
     * "block-size" to be clamped to the "stretch" size. */
    min-block-size: -webkit-fill-available;
    block-size: 0;
    inline-size: 20px;
    background: fuchsia;
  }
```

```json
{
  "errors": 0,
  "messages": [],
  "warnings": 0
}
```
